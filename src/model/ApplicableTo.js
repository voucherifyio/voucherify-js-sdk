/**
 * Voucherify API
 * Voucherify promotion engine REST API. Please see https://docs.voucherify.io/docs for more details.
 *
 * The version of the OpenAPI document: v2018-08-01
 * Contact: support@voucherify.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import ApplicableToEffect from './ApplicableToEffect';
import ApplicableToOrderItemUnitsItem from './ApplicableToOrderItemUnitsItem';

/**
 * The ApplicableTo model module.
 * @module model/ApplicableTo
 * @version v2018-08-01
 */
class ApplicableTo {
    /**
     * Constructs a new <code>ApplicableTo</code>.
     * @alias module:model/ApplicableTo
     * @param effect {module:model/ApplicableToEffect} 
     */
    constructor(effect) { 
        
        ApplicableTo.initialize(this, effect);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj, effect) { 
        obj['effect'] = effect;
    }

    /**
     * Constructs a <code>ApplicableTo</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/ApplicableTo} obj Optional instance to populate.
     * @return {module:model/ApplicableTo} The populated <code>ApplicableTo</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new ApplicableTo();

            if (data.hasOwnProperty('object')) {
                obj['object'] = ApiClient.convertToType(data['object'], 'String');
            }
            if (data.hasOwnProperty('id')) {
                obj['id'] = ApiClient.convertToType(data['id'], 'String');
            }
            if (data.hasOwnProperty('source_id')) {
                obj['source_id'] = ApiClient.convertToType(data['source_id'], 'String');
            }
            if (data.hasOwnProperty('product_id')) {
                obj['product_id'] = ApiClient.convertToType(data['product_id'], 'String');
            }
            if (data.hasOwnProperty('product_source_id')) {
                obj['product_source_id'] = ApiClient.convertToType(data['product_source_id'], 'String');
            }
            if (data.hasOwnProperty('price')) {
                obj['price'] = ApiClient.convertToType(data['price'], 'Number');
            }
            if (data.hasOwnProperty('price_formula')) {
                obj['price_formula'] = ApiClient.convertToType(data['price_formula'], 'Number');
            }
            if (data.hasOwnProperty('effect')) {
                obj['effect'] = ApplicableToEffect.constructFromObject(data['effect']);
            }
            if (data.hasOwnProperty('quantity_limit')) {
                obj['quantity_limit'] = ApiClient.convertToType(data['quantity_limit'], 'Number');
            }
            if (data.hasOwnProperty('aggregated_quantity_limit')) {
                obj['aggregated_quantity_limit'] = ApiClient.convertToType(data['aggregated_quantity_limit'], 'Number');
            }
            if (data.hasOwnProperty('amount_limit')) {
                obj['amount_limit'] = ApiClient.convertToType(data['amount_limit'], 'Number');
            }
            if (data.hasOwnProperty('aggregated_amount_limit')) {
                obj['aggregated_amount_limit'] = ApiClient.convertToType(data['aggregated_amount_limit'], 'Number');
            }
            if (data.hasOwnProperty('order_item_indices')) {
                obj['order_item_indices'] = ApiClient.convertToType(data['order_item_indices'], ['Number']);
            }
            if (data.hasOwnProperty('order_item_units')) {
                obj['order_item_units'] = ApiClient.convertToType(data['order_item_units'], [ApplicableToOrderItemUnitsItem]);
            }
            if (data.hasOwnProperty('repeat')) {
                obj['repeat'] = ApiClient.convertToType(data['repeat'], 'Number');
            }
            if (data.hasOwnProperty('skip_initially')) {
                obj['skip_initially'] = ApiClient.convertToType(data['skip_initially'], 'Number');
            }
            if (data.hasOwnProperty('target')) {
                obj['target'] = ApiClient.convertToType(data['target'], 'String');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>ApplicableTo</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>ApplicableTo</code>.
     */
    static validateJSON(data) {
        // check to make sure all required properties are present in the JSON string
        for (const property of ApplicableTo.RequiredProperties) {
            if (!data.hasOwnProperty(property)) {
                throw new Error("The required field `" + property + "` is not found in the JSON data: " + JSON.stringify(data));
            }
        }
        // ensure the json data is a string
        if (data['object'] && !(typeof data['object'] === 'string' || data['object'] instanceof String)) {
            throw new Error("Expected the field `object` to be a primitive type in the JSON string but got " + data['object']);
        }
        // ensure the json data is a string
        if (data['id'] && !(typeof data['id'] === 'string' || data['id'] instanceof String)) {
            throw new Error("Expected the field `id` to be a primitive type in the JSON string but got " + data['id']);
        }
        // ensure the json data is a string
        if (data['source_id'] && !(typeof data['source_id'] === 'string' || data['source_id'] instanceof String)) {
            throw new Error("Expected the field `source_id` to be a primitive type in the JSON string but got " + data['source_id']);
        }
        // ensure the json data is a string
        if (data['product_id'] && !(typeof data['product_id'] === 'string' || data['product_id'] instanceof String)) {
            throw new Error("Expected the field `product_id` to be a primitive type in the JSON string but got " + data['product_id']);
        }
        // ensure the json data is a string
        if (data['product_source_id'] && !(typeof data['product_source_id'] === 'string' || data['product_source_id'] instanceof String)) {
            throw new Error("Expected the field `product_source_id` to be a primitive type in the JSON string but got " + data['product_source_id']);
        }
        // ensure the json data is an array
        if (!Array.isArray(data['order_item_indices'])) {
            throw new Error("Expected the field `order_item_indices` to be an array in the JSON data but got " + data['order_item_indices']);
        }
        if (data['order_item_units']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['order_item_units'])) {
                throw new Error("Expected the field `order_item_units` to be an array in the JSON data but got " + data['order_item_units']);
            }
            // validate the optional field `order_item_units` (array)
            for (const item of data['order_item_units']) {
                ApplicableToOrderItemUnitsItem.validateJSON(item);
            };
        }
        // ensure the json data is a string
        if (data['target'] && !(typeof data['target'] === 'string' || data['target'] instanceof String)) {
            throw new Error("Expected the field `target` to be a primitive type in the JSON string but got " + data['target']);
        }

        return true;
    }


}

ApplicableTo.RequiredProperties = ["effect"];

/**
 * This object stores information about the resource to which the discount is applicable.
 * @member {module:model/ApplicableTo.ObjectEnum} object
 */
ApplicableTo.prototype['object'] = undefined;

/**
 * Unique product collection, product, or SKU identifier assigned by Voucherify.
 * @member {String} id
 */
ApplicableTo.prototype['id'] = undefined;

/**
 * The source identifier from your inventory system.
 * @member {String} source_id
 */
ApplicableTo.prototype['source_id'] = undefined;

/**
 * Parent product's unique ID assigned by Voucherify.
 * @member {String} product_id
 */
ApplicableTo.prototype['product_id'] = undefined;

/**
 * Parent product's source ID from your inventory system.
 * @member {String} product_source_id
 */
ApplicableTo.prototype['product_source_id'] = undefined;

/**
 * New fixed price of an item. Value is multiplied by 100 to precisely represent 2 decimal places. For example, a $10 price is written as 1000. In case of the fixed price being calculated by the formula, i.e. the price_formula parameter is present in the fixed price definition, this value becomes the fallback value. Such that in a case where the formula cannot be calculated due to missing metadata, for example, this value will be used as the fixed price.
 * @member {Number} price
 */
ApplicableTo.prototype['price'] = undefined;

/**
 * Formula used to dynamically calculate the discounted price of an item.
 * @member {Number} price_formula
 */
ApplicableTo.prototype['price_formula'] = undefined;

/**
 * @member {module:model/ApplicableToEffect} effect
 */
ApplicableTo.prototype['effect'] = undefined;

/**
 * The maximum number of units allowed to be discounted per order line item.
 * @member {Number} quantity_limit
 */
ApplicableTo.prototype['quantity_limit'] = undefined;

/**
 * The maximum number of units allowed to be discounted combined across all matched order line items.
 * @member {Number} aggregated_quantity_limit
 */
ApplicableTo.prototype['aggregated_quantity_limit'] = undefined;

/**
 * Upper limit allowed to be applied as a discount per order line item. Value is multiplied by 100 to precisely represent 2 decimal places. For example, a $6 maximum discount is written as 600.
 * @member {Number} amount_limit
 */
ApplicableTo.prototype['amount_limit'] = undefined;

/**
 * Maximum discount amount per order. Value is multiplied by 100 to precisely represent 2 decimal places. For example, a $6 maximum discount on the entire order is written as 600. This value is definable for the following discount effects: - `APPLY_TO_ITEMS` (each item subtotal is discounted equally) - `APPLY_TO_ITEMS_BY_QUANTITY` (each unit of matched products has the same discount value)
 * @member {Number} aggregated_amount_limit
 */
ApplicableTo.prototype['aggregated_amount_limit'] = undefined;

/**
 * Lists which order lines are (not) covered by the discount. The order in the array is determined by the sequence of applied discounts, while the numbers correspond to the order lines sent in the `order` object in the request. The first order line is assigned `0`, the second order line is assigned `1`, and so on.
 * @member {Array.<Number>} order_item_indices
 */
ApplicableTo.prototype['order_item_indices'] = undefined;

/**
 * Lists which units within order lines are covered by the discount. The order line items are listed according to sequence of applied discounts while the `index` corresponds to the order line sent in the `order` object in the request.
 * @member {Array.<module:model/ApplicableToOrderItemUnitsItem>} order_item_units
 */
ApplicableTo.prototype['order_item_units'] = undefined;

/**
 * Determines the recurrence of the discount, e.g. `\"repeat\": 3` means that the discount is applied to every third item.
 * @member {Number} repeat
 */
ApplicableTo.prototype['repeat'] = undefined;

/**
 * Determines how many items are skipped before the discount is applied.
 * @member {Number} skip_initially
 */
ApplicableTo.prototype['skip_initially'] = undefined;

/**
 * Determines to which kinds of objects the discount is applicable. `ITEM` includes products and SKUs. `UNIT` means particular units within an order line.
 * @member {module:model/ApplicableTo.TargetEnum} target
 */
ApplicableTo.prototype['target'] = undefined;





/**
 * Allowed values for the <code>object</code> property.
 * @enum {String}
 * @readonly
 */
ApplicableTo['ObjectEnum'] = {

    /**
     * value: "product"
     * @const
     */
    "product": "product",

    /**
     * value: "sku"
     * @const
     */
    "sku": "sku",

    /**
     * value: "products_collection"
     * @const
     */
    "products_collection": "products_collection"
};


/**
 * Allowed values for the <code>target</code> property.
 * @enum {String}
 * @readonly
 */
ApplicableTo['TargetEnum'] = {

    /**
     * value: "ITEM"
     * @const
     */
    "ITEM": "ITEM",

    /**
     * value: "UNIT"
     * @const
     */
    "UNIT": "UNIT"
};



export default ApplicableTo;

